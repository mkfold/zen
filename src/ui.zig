const ig = @import("imgui");
const ig_impl = @import("ui/imgui.zig");
const gl = @import("./c.zig").gl;
const Key = @import("app/input.zig").Key;
const Event = @import("app/input.zig").Event;

var ui_initialized: bool = false;

usingnamespace @import("ui/console.zig");
usingnamespace @import("ui/menu.zig");
usingnamespace @import("ui/editor.zig");

pub fn init() void {
    ig_impl.init("#version 330");
    var fcfg = ig.ImFontConfig_ImFontConfig();
    fcfg.*.OversampleH = 2;
    fcfg.*.OversampleV = 2;
    // load_font("assets/fonts/Karla-Regular.ttf", 18.0);
    var sty = ig.igGetStyle();
    var colors = sty.*.Colors;
    colors[ig.ImGuiCol_WindowBg] = .{ .x = 0.06, .y = 0.06, .z = 0.06, .w = 1.00 };
    colors[ig.ImGuiCol_Border] = .{ .x = 0.14, .y = 0.14, .z = 0.14, .w = 1.00 };
    sty.*.WindowRounding = 0;
    ui_initialized = true;
}

pub fn deinit() void {
    ig_impl.Shutdown();
    ui_initialized = false;
}

fn load_font(fname: []const u8, size: f32) void {
    // var fcfg = ig.ImFontConfig_ImFontConfig();
    // _ = ig.ImFontAtlas_AddFontFromFileTTF(io.*.Fonts, fname, size, fcfg, null);
    var io = ig.igGetIO();
    var font = ig.ImFontAtlas_AddFontFromFileTTF(
        io.*.Fonts,
        fname.ptr,
        size,
        null,
        ig.ImFontAtlas_GetGlyphRangesDefault(io.*.Fonts),
    );
    var tex_id = @intCast(c_uint, @ptrToInt(io.*.Fonts.*.TexID));
    gl.glDeleteTextures(1, &tex_id);

    tex_id = 0;
    var data: [*c]u8 = undefined;
    var tex_w: i32 = undefined;
    var tex_h: i32 = undefined;
    ig.ImFontAtlas_GetTexDataAsRGBA32(io.*.Fonts, &data, &tex_w, &tex_h, null);

    gl.glGenTextures(1, &tex_id);
    gl.glBindTexture(gl.GL_TEXTURE_2D, tex_id);
    gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR);
    gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR);
    if (@hasDecl(gl, "GL_UNPACK_ROW_LENGTH")) gl.glPixelStorei(gl.GL_UNPACK_ROW_LENGTH, 0);
    gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_RGBA, tex_w, tex_h, 0, gl.GL_RGBA, gl.GL_UNSIGNED_BYTE, data);
    io.*.Fonts.*.TexID = @intToPtr(*anyopaque, tex_id);
    ig_impl.g_FontTexture = tex_id;
    io.*.FontDefault = font;
}

pub fn begin() void {
    ig.igNewFrame();
}

pub fn render() void {
    if (!ui_initialized) {
        ig.igEndFrame();
        return;
    }

    ig.igRender();
    var draw_data = ig.igGetDrawData();
    ig_impl.RenderDrawData(draw_data);
}

/// send Events generated by a Window to imgui; this is basically just a switch on the event
/// type followed by some light transformations to get the data into the proper format.
pub fn handle_events(events: []Event) void {
    var io = ig.igGetIO();
    for (events) |e| {
        switch (e) {
            .mouse => |m| {
                if (!io.*.WantCaptureMouse) continue;
                const b = @intCast(usize, switch (m.button) {
                    .button1 => ig.ImGuiMouseButton_Left,
                    .button2 => ig.ImGuiMouseButton_Right,
                    .button3 => ig.ImGuiMouseButton_Middle,
                    else => continue,
                });
                io.*.MouseDown[b] = (m.action == .press or m.action == .repeat);
            },
            .cursor => |cur| {
                if (!io.*.WantCaptureMouse) continue;
                io.*.MousePos = .{ .x = @floatCast(f32, cur.xpos), .y = @floatCast(f32, cur.ypos) };
            },
            .char => |c| if (io.*.WantTextInput) ig.ImGuiIO_AddInputCharacter(io, c.codepoint),
            .key => |k| {
                if (!io.*.WantCaptureKeyboard) continue;
                const ki = @intCast(usize, @enumToInt(k.key));
                io.*.KeysDown[ki] = (k.action == .press or k.action == .repeat);

                {
                    const lsi = @intCast(usize, @enumToInt(Key.left_shift));
                    const rsi = @intCast(usize, @enumToInt(Key.right_shift));
                    io.*.KeyShift = io.*.KeysDown[lsi] or io.*.KeysDown[rsi];
                }
                {
                    const lci = @intCast(usize, @enumToInt(Key.left_ctrl));
                    const rci = @intCast(usize, @enumToInt(Key.right_ctrl));
                    io.*.KeyCtrl = io.*.KeysDown[lci] or io.*.KeysDown[rci];
                }
                {
                    const lai = @intCast(usize, @enumToInt(Key.left_alt));
                    const rai = @intCast(usize, @enumToInt(Key.right_alt));
                    io.*.KeyAlt = io.*.KeysDown[lai] or io.*.KeysDown[rai];
                }
            },
            .resize => |r| io.*.DisplaySize = .{
                .x = @intToFloat(f32, r.width),
                .y = @intToFloat(f32, r.height),
            },
            .scroll => |s| {
                if (!io.*.WantCaptureMouse) continue;
                io.*.MouseWheel = @floatCast(f32, s.yoffs);
                io.*.MouseWheelH = @floatCast(f32, s.xoffs);
            },
        }
    }
    // zig fmt: on
}

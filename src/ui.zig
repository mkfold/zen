const ig = @import("imgui");
const ig_impl = @import("ui/imgui.zig");
const gl = @import("./c.zig").gl;
const Key = @import("app/input.zig").Key;
const Event = @import("app/input.zig").Event;

var ui_initialized: bool = false;

usingnamespace @import("ui/console.zig");
usingnamespace @import("ui/menu.zig");
usingnamespace @import("ui/editor.zig");

pub fn init() void {
    ig_impl.init("#version 330");
    var fcfg = ig.ImFontConfig_ImFontConfig();
    fcfg.*.OversampleH = 2;
    fcfg.*.OversampleV = 2;
    // load_font("assets/fonts/Karla-Regular.ttf", 18.0);
    var sty = ig.igGetStyle();
    var colors = sty.*.Colors;
    colors[ig.ImGuiCol_WindowBg] = .{ .x = 0.06, .y = 0.06, .z = 0.06, .w = 1.00 };
    colors[ig.ImGuiCol_Border] = .{ .x = 0.14, .y = 0.14, .z = 0.14, .w = 1.00 };
    sty.*.WindowRounding = 0;
    ui_initialized = true;
}

pub fn deinit() void {
    ig_impl.Shutdown();
    ui_initialized = false;
}

fn load_font(fname: []const u8, size: f32) void {
    // var fcfg = ig.ImFontConfig_ImFontConfig();
    // _ = ig.ImFontAtlas_AddFontFromFileTTF(io.*.Fonts, fname, size, fcfg, null);
    var io = ig.igGetIO();
    var font = ig.ImFontAtlas_AddFontFromFileTTF(
        io.*.Fonts,
        fname.ptr,
        size,
        null,
        ig.ImFontAtlas_GetGlyphRangesDefault(io.*.Fonts),
    );
    var tex_id = @intCast(c_uint, @ptrToInt(io.*.Fonts.*.TexID));
    gl.glDeleteTextures(1, &tex_id);

    tex_id = 0;
    var data: [*c]u8 = undefined;
    var tex_w: i32 = undefined;
    var tex_h: i32 = undefined;
    ig.ImFontAtlas_GetTexDataAsRGBA32(io.*.Fonts, &data, &tex_w, &tex_h, null);

    gl.glGenTextures(1, &tex_id);
    gl.glBindTexture(gl.GL_TEXTURE_2D, tex_id);
    gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR);
    gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR);
    if (@hasDecl(gl, "GL_UNPACK_ROW_LENGTH")) gl.glPixelStorei(gl.GL_UNPACK_ROW_LENGTH, 0);
    gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_RGBA, tex_w, tex_h, 0, gl.GL_RGBA, gl.GL_UNSIGNED_BYTE, data);
    io.*.Fonts.*.TexID = @intToPtr(*anyopaque, tex_id);
    ig_impl.g_FontTexture = tex_id;
    io.*.FontDefault = font;
}

pub fn begin() void {
    ig.igNewFrame();
}

pub fn render() void {
    if (!ui_initialized) {
        ig.igEndFrame();
        return;
    }

    ig.igRender();
    var draw_data = ig.igGetDrawData();
    ig_impl.RenderDrawData(draw_data);
}

pub fn handle_mouse(event: Event.Mouse) void {
    var io = ig.igGetIO();
    const b = @intCast(usize, switch (event.button) {
        .button1 => ig.ImGuiMouseButton_Left,
        .button2 => ig.ImGuiMouseButton_Right,
        .button3 => ig.ImGuiMouseButton_Middle,
        else => return,
    });
    io.*.MouseDown[b] = (event.action == .press or event.action == .repeat);
}

pub fn handle_cursor(event: Event.Cursor) void {
    var io = ig.igGetIO();
    io.*.MousePos = .{
        .x = @floatCast(f32, event.xpos),
        .y = @floatCast(f32, event.ypos),
    };
}

pub fn handle_char(event: Event.CharInput) void {
    var io = ig.igGetIO();
    ig.ImGuiIO_AddInputCharacter(io, event.codepoint);
}

pub fn handle_key(event: Event.Keyboard) void {
    var io = ig.igGetIO();
    const ki = @intCast(usize, @enumToInt(event.key));
    io.*.KeysDown[ki] = (event.action == .press or event.action == .repeat);

    {
        const lsi = @intCast(usize, @enumToInt(Key.left_shift));
        const rsi = @intCast(usize, @enumToInt(Key.right_shift));
        io.*.KeyShift = io.*.KeysDown[lsi] or io.*.KeysDown[rsi];
    }
    {
        const lci = @intCast(usize, @enumToInt(Key.left_ctrl));
        const rci = @intCast(usize, @enumToInt(Key.right_ctrl));
        io.*.KeyCtrl = io.*.KeysDown[lci] or io.*.KeysDown[rci];
    }
    {
        const lai = @intCast(usize, @enumToInt(Key.left_alt));
        const rai = @intCast(usize, @enumToInt(Key.right_alt));
        io.*.KeyAlt = io.*.KeysDown[lai] or io.*.KeysDown[rai];
    }
}

pub fn handle_resize(event: Event.Resize) void {
    var io = ig.igGetIO();
    io.*.DisplaySize = .{
        .x = @intToFloat(f32, event.width),
        .y = @intToFloat(f32, event.height),
    };
}

pub fn handle_scroll(event: Event.Scroll) void {
    var io = ig.igGetIO();
    io.*.MouseWheel = @floatCast(f32, event.yoffs);
    io.*.MouseWheelH = @floatCast(f32, event.xoffs);
}

/// send Events generated by a Window to imgui; this is basically just a switch on the event
/// type followed by some light transformations to get the data into the proper format.
pub fn handle_events(events: []Event) void {
    for (events) |e| {
        switch (e) {
            .mouse => |x| handle_mouse(x),
            .cursor => |x| handle_cursor(x),
            .char => |x| handle_char(x),
            .key => |x| handle_key(x),
            .resize => |x| handle_resize(x),
            .scroll => |x| handle_scroll(x),
        }
    }
}
